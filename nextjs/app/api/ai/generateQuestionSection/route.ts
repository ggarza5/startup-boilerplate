import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { zodResponseFormat } from 'openai/helpers/zod';
import { z } from 'zod';
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

const supabase = createClient(supabaseUrl, supabaseKey);

const QuestionSchema = z.object({
  question: z.string(),
  answer_choices: z.array(z.string()),
  answer: z.string(),
  explanation: z.string(),
});

const SectionSchema = z.object({
  questions: z.array(QuestionSchema),
});

export async function POST(request: NextRequest) {
  const { sectionName } = await request.json();

  const prompt = `Generate a ${sectionName} SAT question section with questions, answers, and explanations that address each choice. Return in json format. I need these fields: question, answer_choices, answer, explanation. Answer_choices should be an array of strings, others should be string`;

  const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY
  });

  // Call OpenAI API
  const completion = await openai.beta.chat.completions.parse({
    model: "gpt-4o-mini-2024-07-18",
    messages: [{ role: "user", content: prompt }],
    response_format: zodResponseFormat(SectionSchema, "section"),
  });

  const generatedText = completion.choices[0].message.parsed;
  if (!generatedText) {
    return NextResponse.json({ error: 'No content generated by OpenAI' }, { status: 500 });
  }

  // Create a new section
  const { data: sectionData, error: sectionError } = await supabase
    .from('sections')
    .insert([
      { section_type: sectionName }  // Assuming sectionName is the type of the section
    ])
    .select('id')
    .single();

  if (sectionError) {
    // Handle error
    return new Response(JSON.stringify({ error: "Error in setting section: " + sectionError.message }), { status: 500 });
  }

  const sectionId = sectionData.id;

  // Parse generatedText.questions into an array
  const questions = generatedText.questions;

  // Store each question and answer in Supabase
  for (const question of questions) {
    const { data: questionData, error: questionError } = await supabase
      .from('questions')
      .insert([
        { 
          section_id: sectionId,  // Use the newly created section ID
          question: question.question,
          answer_choices: question.answer_choices,
          answer: question.answer,
          explanation: question.explanation
        }
      ]);

    if (questionError) {
      // Handle error
      return new Response(JSON.stringify({ error: "Error in setting question: " + questionError.message }), { status: 500 });
    }
  }

  return NextResponse.json({ answer: generatedText, sectionId: sectionId });
}