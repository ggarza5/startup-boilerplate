import OpenAI from 'openai';
import { zodResponseFormat } from 'openai/helpers/zod';
import { z } from 'zod';
import { createClient } from '@supabase/supabase-js';

// Initialize Supabase client
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
const supabase = createClient(supabaseUrl, supabaseKey);

// Define the schema for a question using Zod
const QuestionSchema = z.object({
  question: z.string(),
  answer_choices: z.array(z.string()),
  answer: z.string(),
  explanation: z.string()
});

// Define the schema for a section using Zod
const SectionSchema = z.object({
  questions: z.array(QuestionSchema)
});

// Function to generate a new section using OpenAI and store it in Supabase
export const generateSection = async (
  sectionName: string,
  sectionType: string,
  category?: string
) => {
  console.log(
    `generating a ${sectionType} section with category: ${category || 'none'}`
  );

  let prompt;

  if (category) {
    prompt = `Generate a 10 question ${sectionType} SAT question section focused on the category "${category}" with questions, answers, and explanations that address each choice. 
    Return in json format. I need these fields: question, answer_choices, answer, explanation. 
    Answer_choices should be an array of strings, others should be string. 
    Reading questions that refer to a passage should include the passage in the question field.
    All questions should be appropriate for the ${category} category of the ${sectionType} section of the SAT.`;
  } else {
    prompt = `Generate a 10 question ${sectionType} SAT question section with questions, answers, and explanations that address each choice. 
    Return in json format. I need these fields: question, answer_choices, answer, explanation. 
    Answer_choices should be an array of strings, others should be string. 
    Reading questions that refer to a passage should include the passage in the question field`;
  }

  const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY
  });

  // Call OpenAI API to generate the section
  const completion: any = await openai.chat.completions.create({
    model: 'gpt-4o-mini',
    messages: [{ role: 'user', content: prompt }],
    response_format: zodResponseFormat(SectionSchema, 'section')
  });

  const generatedText = completion['choices'][0].message.content;
  if (!generatedText) {
    throw new Error('No content generated by OpenAI');
  }

  // Create a new section in Supabase
  const { data: sectionData, error: sectionError } = await supabase
    .from('sections')
    .insert([
      { name: sectionName, section_type: sectionType, category: category } // Add category field
    ])
    .select('*')
    .single();

  if (sectionError) {
    throw new Error('Error in setting section: ' + sectionError.message);
  }

  const sectionId = sectionData.id;

  //generatedText is a string, so we need to parse it as json
  const generatedTextJson = JSON.parse(generatedText);

  const questions = generatedTextJson.questions;

  // Store each question and answer in Supabase
  for (const question of questions) {
    const { error: questionError } = await supabase.from('questions').insert([
      {
        section_id: sectionId, // Use the newly created section ID
        question: question.question,
        answer_choices: question.answer_choices,
        answer: question.answer,
        explanation: question.explanation
      }
    ]);

    if (questionError) {
      throw new Error('Error in setting question: ' + questionError.message);
    }
  }

  return {
    answer: generatedText,
    sectionId: sectionId,
    name: sectionName,
    type: sectionType,
    category: category,
    created_at: sectionData.created_at
  };
};
