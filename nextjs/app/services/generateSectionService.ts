import OpenAI from 'openai';
import { zodResponseFormat } from 'openai/helpers/zod';
import { z } from 'zod';
import { createClient } from '@supabase/supabase-js';

// Initialize Supabase client
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
const supabase = createClient(supabaseUrl, supabaseKey);

// Define the schema for a question using Zod
const QuestionSchema = z.object({
  question: z.string(),
  answer_choices: z.array(z.string()),
  answer: z.string(),
  explanation: z.string()
});

// Define the schema for a section using Zod
const SectionSchema = z.object({
  section_title: z.string(),
  questions: z.array(QuestionSchema)
});

// Function to generate a new section using OpenAI and store it in Supabase
export const generateSection = async (
  sectionName: string,
  sectionType: string,
  category?: string
) => {
  console.log(
    `generateSectionService: generating a ${sectionType} section with category: ${category}`
  );

  let prompt;

  if (category) {
    console.log(
      `generateSectionService: Using category in prompt: ${category}`
    );
    prompt = `Generate a 10 question ${sectionType} SAT question section focused on the category "${category}". Include a short, relevant title for the section. 
    Return in json format. I need these fields: section_title (string), questions (array). 
    For each question, provide: question (string), answer_choices (array of strings), answer (string), explanation (string). 
    Reading questions that refer to a passage should include the passage in the question field.
    All questions should be appropriate for the ${category} category of the ${sectionType} section of the SAT.`;
  } else {
    prompt = `Generate a 10 question ${sectionType} SAT question section. Include a short, relevant title for the section.
    Return in json format. I need these fields: section_title (string), questions (array).
    For each question, provide: question (string), answer_choices (array of strings), answer (string), explanation (string).
    Reading questions that refer to a passage should include the passage in the question field`;
  }

  const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY
  });

  // Call OpenAI API to generate the section
  const completion: any = await openai.chat.completions.create({
    model: 'o3-mini-2025-01-31',
    messages: [{ role: 'user', content: prompt }],
    response_format: zodResponseFormat(SectionSchema, 'section'),
    reasoning_effort: 'high'
  });

  const generatedText = completion['choices'][0].message.content;
  if (!generatedText) {
    throw new Error('No content generated by OpenAI');
  }

  //generatedText is a string, so we need to parse it as json
  const generatedTextJson = JSON.parse(generatedText);
  const generatedTitle = generatedTextJson.section_title; // Get the title
  const questions = generatedTextJson.questions;

  if (!generatedTitle) {
    console.warn('OpenAI did not return a section_title. Using default name.');
    // Potentially use sectionName (the timestamped one) or a default as fallback
  }

  // Create a new section in Supabase
  console.log(
    `generateSectionService: Inserting into Supabase with name: ${generatedTitle || sectionName}, type: ${sectionType}, category: ${category}`
  );
  const { data: sectionData, error: sectionError } = await supabase
    .from('sections')
    .insert([
      {
        name: generatedTitle || sectionName,
        section_type: sectionType,
        category: category
      } // Use generated title or fallback
    ])
    .select('*')
    .single();

  if (sectionError) {
    throw new Error('Error in setting section: ' + sectionError.message);
  }

  const sectionId = sectionData.id;

  // Store each question and answer in Supabase
  for (const question of questions) {
    const { error: questionError } = await supabase.from('questions').insert([
      {
        section_id: sectionId, // Use the newly created section ID
        question: question.question,
        answer_choices: question.answer_choices,
        answer: question.answer,
        explanation: question.explanation
      }
    ]);

    if (questionError) {
      throw new Error('Error in setting question: ' + questionError.message);
    }
  }

  return {
    answer: generatedText,
    sectionId: sectionId,
    name: generatedTitle || sectionName, // Return the used name
    type: sectionType,
    category: category,
    created_at: sectionData.created_at
  };
};
